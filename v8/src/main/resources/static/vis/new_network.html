<html lang="en">
<head>
    <meta charset="utf-8">
    <title>网状图示例</title>
    <style>
        #PARAGRAPH_ID_iframe_container {
            min-height: 400px;
            max-height: 600px;
        }
        #PARAGRAPH_ID_single_container {
            width: 100%;
            height: 500px;
            background-color: #ffffff;
            position: relative;
            float: left;
        }
        .card-body {
            position: relative;
        }
        .card {
            position: relative;
            display: flex;
            flex-direction: column;
            min-width: 0;
            background-color: #fff;
            border-radius: .25rem;
            min-height: 400px;
            max-height: 600px;
        }
        .toggle-button {
            padding: 0 5px;
            border: none;
            background-color: transparent;
            color: inherit;
            cursor: pointer;
            font-size: 14px;
            display: block;
            margin: 10px;
        }
        .toggle-button::before {
            content: ">> ";
            color: #333;
        }
        .toggle-button:hover {
            color: #2e70a8;
        }
        .toggle-button:hover::before {
            color: #2e70a8;
        }
    </style>
</head>

<body>
<button id="PARAGRAPH_ID_toggleButton" class="toggle-button">显示数据资产</button>
<div id="PARAGRAPH_ID_iframe_container" style="display: none">
    <div class="card" style="width: 100%">
        <div id="PARAGRAPH_ID_single_container" class="card-body"></div>
    </div>
</div>

<script type="text/javascript">
    function loadLibrary(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }

    async function init() {
        try {
            // 加载资源
            await loadLibrary('https://unpkg.com/vis-network@9.1.9/standalone/umd/vis-network.min.js');
            await loadLibrary('https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js');
            await loadLibrary('https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js');

            const allNodesStr = 'NODE_LIST';
            const allNodes = JSON.parse(allNodesStr);

            const rootNodes = allNodes.filter(node => node.depth === 1);
            let network;
            let relationHash = {};
            let nodes = [];
            let edges = [];
            let data = {
                nodes: new vis.DataSet(nodes),
                edges: new vis.DataSet(edges)
            };


            // 初始化根节点
            function initializeGraph() {
                allNodes.forEach(item => {
                    if (item.depth === 0) {
                        data.nodes.add({
                            id: item.id,
                            label: item.name || "数据资产",
                            font: { size: 20 },
                            color: '#97c2fc',
                            shape: 'ellipse'
                        });
                        expandNode(item.id);
                        isExpanded[item.id] = true;
                    }
                });
            }

            // 扩展结点
            function expandNode(parentId) {
                const childNodes = allNodes.filter(item => item.parent === parentId);
                let edgesToAdd = [];
                childNodes.forEach(child => {
                    if (!data.nodes.get(child.id)) {
                        data.nodes.add({
                            id: child.id,
                            label: child.name,
                            depth: child.depth,
                            parent: child.parent,
                            embedding: child.embedding,
                            font: {size: 20},
                            color: getColorByDepth(child.depth),
                            shape: 'ellipse'
                        });
                    }
                    edgesToAdd.push({
                        from: parentId,
                        to: child.id,
                        arrows: 'to'
                    });
                });
                data.edges.add(edgesToAdd);
                columnNodesCache[parentId] = childNodes.map(child => child.id);
                isExpanded[parentId] = true;
                if (RELATION_SWITCH) {
                    const parent = data.nodes.get(parentId);
                    calculateNodeRelations(parent);
                }
            }

            // 收缩结点
            function collapseNode(parentId) {
                const childNodeIds = columnNodesCache[parentId] || [];
                childNodeIds.forEach(childId => {
                    collapseNode(childId);
                    data.nodes.remove(childId);
                });
                data.edges.forEach(edge => {
                    if (edge.from === parentId) {
                        data.edges.remove(edge.id);
                    }
                });
                isExpanded[parentId] = false;
                if (RELATION_SWITCH) {
                    analyzeRelations();
                }
            }

            // 绘制图
            function drawGraph() {
                const container = document.getElementById('PARAGRAPH_ID_single_container');
                const options = {
                    autoResize: true,
                    width: '100%',
                    height: "500px",
                    physics: {
                        enabled: true, // 启用物理引擎
                        solver: 'forceAtlas2Based', // 使用更适合层次图的布局算法
                        stabilization: {
                            enabled: true, // 启用稳定化
                            iterations: 200, // 减少动画的剧烈变化
                            updateInterval: 25
                        },
                        forceAtlas2Based: {
                            gravitationalConstant: -50, // 减小吸引力，值越负，吸引力越小
                            centralGravity: 0.01, // 减小中心点吸引力
                            springLength: 100, // 增加边的自然长度
                            springConstant: 0.05, // 减小边的弹性系数，弹性越小，动画越柔和
                            damping: 0.3 // 增大阻尼，值越大，动画越慢且更丝滑
                        },
                        maxVelocity: 10, // 限制最大速度，值越小，移动越缓慢
                        minVelocity: 0.1, // 限制最小速度，避免节点卡住
                    },
                    edges: {
                        arrows: {
                            to: { enabled: true }
                        }
                    }
                };
                network = new vis.Network(container, data, options);

                // 绑定双击事件
                network.on('doubleClick', function (params) {
                    if (params.nodes.length > 0) {
                        const nodeId = params.nodes[0];
                        if (isExpanded[nodeId]) {
                            collapseNode(nodeId);
                        } else {
                            expandNode(nodeId);
                        }
                    }
                });
            }

            // 修改节点的颜色根据深度设置
            function getColorByDepth(depth) {
                switch (depth) {
                    case 0:
                        return '#97c2fc'; // 深度为0的颜色
                    case 1:
                        return '#ffb6c1'; // 深度为1的颜色
                    case 2:
                        return '#f9a825'; // 深度为2的颜色
                    case 3:
                        return '#8bc34a'; // 深度为3的颜色
                    default:
                        return '#c5e1a5'; // 默认颜色
                }
            }

            // 清除结点间额外关系的边
            function clearRelation() {
                const edgesArray = data.edges.get();
                const edgesToRemove = edgesArray.filter(edge => {
                    const hasArrow = edge.arrows && edge.arrows !== ""; // 是否有箭头
                    const isRedColor = edge.color && edge.color === "red"; // 是否为红色
                    return !hasArrow && isRedColor; // 删除无箭头且红色的边
                });
                edgesToRemove.forEach(edge => {
                    data.edges.remove(edge.id);
                });
            }

            // 绘制结点间额外关系的边
            function drawLinks(links) {
                links.forEach(link => {
                    data.edges.add({
                        id: `${link.from}->${link.to}`,
                        from: link.from,
                        to: link.to,
                        arrows: "",
                        color: "red",
                        label: link.relation,
                        font: { align: "top" }
                    });
                });
            }

            // 初始化图形
            initializeGraph();
            drawGraph();

            document.getElementById('PARAGRAPH_ID_toggleButton').addEventListener('click', function() {
                var container = document.getElementById('PARAGRAPH_ID_iframe_container');
                if (container.style.display === 'none' || container.classList.contains('hidden')) {
                    // 显示图表
                    container.style.display = 'block';
                    network.fit();
                    network.redraw();
                    this.innerText="隐藏数据资产"
                } else {
                    // 隐藏图表
                    container.style.display = 'none';
                    this.innerText="显示数据资产"
                }
            });

        } catch (error) {
            console.error('加载过程中出错:', error);
        }
    }

    // 初始化
    init();

</script>
</body>
</html>