<html lang="en">
<head>
    <meta charset="utf-8">
    <title>网状图示例</title>
    <style>
        #PARAGRAPH_ID_iframe_container {
            min-height: 400px;
            max-height: 600px;
        }
        #PARAGRAPH_ID_single_container {
            width: 100%;
            height: 500px;
            background-color: #ffffff;
            position: relative;
            float: left;
        }
        .card-body {
            position: relative;
        }
        .card {
            position: relative;
            display: flex;
            flex-direction: column;
            min-width: 0;
            background-color: #fff;
            border-radius: .25rem;
            min-height: 400px;
            max-height: 600px;
        }
        .toggle-button {
            padding: 0 5px;
            border: none;
            background-color: transparent;
            color: inherit;
            cursor: pointer;
            font-size: 14px;
            display: block;
            margin: 10px;
        }
        .toggle-button::before {
            content: ">> ";
            color: #333;
        }
        .toggle-button:hover {
            color: #2e70a8;
        }
        .toggle-button:hover::before {
            color: #2e70a8;
        }
    </style>
</head>

<body>
<button id="PARAGRAPH_ID_toggleButton" class="toggle-button">显示数据资产</button>
<div id="PARAGRAPH_ID_iframe_container" style="display: none">
    <div class="card" style="width: 100%">
        <div id="PARAGRAPH_ID_single_container" class="card-body"></div>
    </div>
</div>

<script type="text/javascript">
    function loadLibrary(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }

    function loadCSS(href) {
        return new Promise((resolve, reject) => {
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = href;
            link.onload = resolve;
            link.onerror = reject;
            document.head.appendChild(link);
        });
    }

    async function init() {
        try {
            // 加载资源
            await loadLibrary('https://unpkg.com/vis-network@9.1.9/standalone/umd/vis-network.min.js');
            await loadCSS('https://unpkg.com/vis-network@9.1.9/styles/vis-network.min.css');
            await loadLibrary('https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js');
            await loadCSS('https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css');
            await loadLibrary('https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js');

            const RELATION_THRESHOLD = 0.8;
            const RELATION_DEPTH_LEVEL = 3;
            const RELATION_SWITCH = GET_RELATION;
            const allNodesStr = 'NODE_LIST';
            const allNodes = JSON.parse(allNodesStr);

            const rootNodes = allNodes.filter(node => node.depth === 1);
            let network;
            let relationHash = {};
            let nodes = [];
            let edges = [];
            let data = {
                nodes: new vis.DataSet(nodes),
                edges: new vis.DataSet(edges)
            };

            let isExpanded = {}; // 节点展开状态
            let columnNodesCache = {}; // 子节点缓存

            // 初始化根节点
            function initializeGraph() {
                allNodes.forEach(item => {
                    if (item.depth === 0) {
                        data.nodes.add({
                            id: item.id,
                            label: item.name || "数据资产",
                            font: { size: 20 },
                            color: '#97c2fc',
                            shape: 'ellipse'
                        });
                        expandNode(item.id);
                        isExpanded[item.id] = true;
                    }
                });
            }

            // 扩展结点
            function expandNode(parentId) {
                const childNodes = allNodes.filter(item => item.parent === parentId);
                let edgesToAdd = [];
                childNodes.forEach(child => {
                    if (!data.nodes.get(child.id)) {
                        data.nodes.add({
                            id: child.id,
                            label: child.name,
                            depth: child.depth,
                            parent: child.parent,
                            embedding: child.embedding,
                            font: {size: 20},
                            color: getColorByDepth(child.depth),
                            shape: 'ellipse'
                        });
                    }
                    edgesToAdd.push({
                        from: parentId,
                        to: child.id,
                        arrows: 'to'
                    });
                });
                data.edges.add(edgesToAdd);
                columnNodesCache[parentId] = childNodes.map(child => child.id);
                isExpanded[parentId] = true;
                if (RELATION_SWITCH) {
                    const parent = data.nodes.get(parentId);
                    calculateNodeRelations(parent);
                }
            }

            // 收缩结点
            function collapseNode(parentId) {
                const childNodeIds = columnNodesCache[parentId] || [];
                childNodeIds.forEach(childId => {
                    collapseNode(childId);
                    data.nodes.remove(childId);
                });
                data.edges.forEach(edge => {
                    if (edge.from === parentId) {
                        data.edges.remove(edge.id);
                    }
                });
                isExpanded[parentId] = false;
                if (RELATION_SWITCH) {
                    analyzeRelations();
                }
            }

            // 绘制图
            function drawGraph() {
                const container = document.getElementById('PARAGRAPH_ID_single_container');
                const options = {
                    autoResize: true,
                    width: '100%',
                    height: "500px",
                    physics: {
                        enabled: true, // 启用物理引擎
                        solver: 'forceAtlas2Based', // 使用更适合层次图的布局算法
                        stabilization: {
                            enabled: true, // 启用稳定化
                            iterations: 200, // 减少动画的剧烈变化
                            updateInterval: 25
                        },
                        forceAtlas2Based: {
                            gravitationalConstant: -50, // 减小吸引力，值越负，吸引力越小
                            centralGravity: 0.01, // 减小中心点吸引力
                            springLength: 100, // 增加边的自然长度
                            springConstant: 0.05, // 减小边的弹性系数，弹性越小，动画越柔和
                            damping: 0.3 // 增大阻尼，值越大，动画越慢且更丝滑
                        },
                        maxVelocity: 10, // 限制最大速度，值越小，移动越缓慢
                        minVelocity: 0.1, // 限制最小速度，避免节点卡住
                    },
                    edges: {
                        arrows: {
                            to: { enabled: true }
                        }
                    }
                };
                network = new vis.Network(container, data, options);

                // 绑定双击事件
                network.on('doubleClick', function (params) {
                    if (params.nodes.length > 0) {
                        const nodeId = params.nodes[0];
                        if (isExpanded[nodeId]) {
                            collapseNode(nodeId);
                        } else {
                            expandNode(nodeId);
                        }
                    }
                });
            }

            // 修改节点的颜色根据深度设置
            function getColorByDepth(depth) {
                switch (depth) {
                    case 0:
                        return '#97c2fc'; // 深度为0的颜色
                    case 1:
                        return '#ffb6c1'; // 深度为1的颜色
                    case 2:
                        return '#f9a825'; // 深度为2的颜色
                    case 3:
                        return '#8bc34a'; // 深度为3的颜色
                    default:
                        return '#c5e1a5'; // 默认颜色
                }
            }

            async function getResponse(prompt) {
                const API_KEY = "204a3ea9bf39f18dd9bf32c71ecbb607.mITgz6pgV7Hzj27A";
                const API_URL = "https://open.bigmodel.cn/api/paas/v4/chat/completions";
                try {
                    const requestBody = {model: "GLM-4-Flash", messages: [{role: "user", content: prompt}]};
                    const response = await fetch(API_URL, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "Authorization": `Bearer ${API_KEY}`
                        },
                        body: JSON.stringify(requestBody)
                    });
                    if (response.ok) {
                        const jsonResponse = await response.json();
                        return jsonResponse.choices[0].message.content;
                    } else {
                        return `Error: ${response.status} - ${await response.text()}`;
                    }
                } catch (error) {
                    return "getResponse error occurred";
                }
            }

            // 获取两个结点的关系
            async function getRelation(node1Id, node2Id) {
                const name1 = node1Id.split('.').pop();
                const name2 = node2Id.split('.').pop();
                const prompt = `你是一个概念大师，请你给出“${name1}”和“${name2}”之间切实具体、简洁精炼的关系，最好不超过10个字，并用大括号包裹返回，如"{包含}"。`;
                try {
                    let stdResponse = getStdResponse(await getResponse(prompt));
                    if (stdResponse === "") {
                        stdResponse = getStdResponse(await getResponse(prompt));
                    }
                    return stdResponse;
                } catch (error) {
                    console.error("获取关系失败：", error);
                    return { relation: "未知", score: 0 };
                }
            }

            function getStdResponse(response) {
                const regex = /\{(.*?)\}/;
                const match = response.match(regex);
                if (match) {
                    return match[1];
                }
                return "";
            }

            // 获取结点的树根
            function getRootId(str) {
                const parts = str.split('.');
                return parts[0] + "." + parts[1];
            }

            // 根据两个结点id获取key
            function getKeyWithIds(a, b) {
                if (a.localeCompare(b) < 0) {return a + "-" + b;}
                else {return b + "-" + a;}
            }

            // 计算离散余弦相似度
            function cosineSimilarity(embedding1, embedding2) {
                const dotProduct = embedding1.reduce((sum, val, idx) => sum + val * embedding2[idx], 0);
                const magnitude1 = Math.sqrt(embedding1.reduce((sum, val) => sum + val ** 2, 0));
                const magnitude2 = Math.sqrt(embedding2.reduce((sum, val) => sum + val ** 2, 0));
                if (magnitude1 === 0 || magnitude2 === 0) {
                    throw new Error("向量的模长不能为零！");
                }
                return dotProduct / (magnitude1 * magnitude2);
            }

            // 清除结点间额外关系的边
            function clearRelation() {
                const edgesArray = data.edges.get();
                const edgesToRemove = edgesArray.filter(edge => {
                    const hasArrow = edge.arrows && edge.arrows !== ""; // 是否有箭头
                    const isRedColor = edge.color && edge.color === "red"; // 是否为红色
                    return !hasArrow && isRedColor; // 删除无箭头且红色的边
                });
                edgesToRemove.forEach(edge => {
                    data.edges.remove(edge.id);
                });
            }

            // 绘制结点间额外关系的边
            function drawLinks(links) {
                links.forEach(link => {
                    data.edges.add({
                        id: `${link.from}->${link.to}`,
                        from: link.from,
                        to: link.to,
                        arrows: "",
                        color: "red",
                        label: link.relation,
                        font: { align: "top" }
                    });
                });
            }

            // 分析结点间的关系，确定要添加的边
            async function analyzeRelations() {
                console.log("<===begin analyzeRelations");
                clearRelation();
                let links = [];

                for (let i = 0; i < rootNodes.length; i++) {
                    for (let j = i + 1; j < rootNodes.length; j++) {
                        const tree1 = rootNodes[i];
                        const tree2 = rootNodes[j];
                        const key = getKeyWithIds(tree1.id, tree2.id);

                        if (relationHash[key] &&  Object.keys(relationHash[key]).length > 0) {
                            const filteredLinks = Object.values(relationHash[key]).filter(link => link.score >= RELATION_THRESHOLD);
                            const bestMatch = filteredLinks.sort((a, b) => b.score - a.score)[0];

                            if (bestMatch) {
                                if (!bestMatch["relation"]) {
                                    bestMatch["relation"] = await getRelation(bestMatch.from, bestMatch.to);
                                }

                                // 将结果存入 links
                                links.push({
                                    from: bestMatch.from,
                                    to: bestMatch.to,
                                    relation: bestMatch.relation,
                                    score: bestMatch.score
                                });
                            }
                        }
                    }
                }
                console.log("links为：" + JSON.stringify(links));
                drawLinks(links);
            }

            // 计算结点间的关系
            async function calculateNodeRelations(node) {
                console.log("<===calculateNodeRelations: " + node.id);
                if (node.depth >= RELATION_DEPTH_LEVEL) return;
                const visibleNodes = Array.from(data.nodes.get()).filter(node => node.depth >= 1 && node.depth <= RELATION_DEPTH_LEVEL);
                const nodeChildren = allNodes.filter(child => child.parent === node.id);
                console.log(visibleNodes);

                for (const child of nodeChildren) {
                    for (const otherNode of visibleNodes) {
                        const rootId1 = getRootId(child.id);
                        const rootId2 = getRootId(otherNode.id);
                        if (rootId1 === rootId2) continue;

                        const bucket = getKeyWithIds(rootId1, rootId2);
                        if (!relationHash[bucket]) {
                            relationHash[bucket] = {};
                        }

                        const key = getKeyWithIds(child.id, otherNode.id);
                        if (!relationHash[bucket][key]) {
                            const score = cosineSimilarity(child.embedding, otherNode.embedding);
                            relationHash[bucket][key] = {
                                from: child.id,
                                to: otherNode.id,
                                score: score,
                            };
                        }
                    }
                }

                console.log("relationHash为：" + JSON.stringify(relationHash));
                analyzeRelations();
            }

            // 初始化图形
            initializeGraph();
            drawGraph();

            document.getElementById('PARAGRAPH_ID_toggleButton').addEventListener('click', function() {
                var container = document.getElementById('PARAGRAPH_ID_iframe_container');
                if (container.style.display === 'none' || container.classList.contains('hidden')) {
                    // 显示图表
                    container.style.display = 'block';
                    network.fit();
                    network.redraw();
                    this.innerText="隐藏数据资产"
                } else {
                    // 隐藏图表
                    container.style.display = 'none';
                    this.innerText="显示数据资产"
                }
            });

        } catch (error) {
            console.error('加载过程中出错:', error);
        }
    }

    // 初始化
    init();

</script>
</body>
</html>